#!/bin/env python
# Requires: ffmpeg sox librosa mutagen python3

import os
import random
import subprocess
import logging
import configparser
import time

def extract_id3_tags(track):
    try:
        # Extract ID3 tags from input MP3 file
        tag_command = f'sox --show-tags "{track}"'
        tags_output = subprocess.check_output(tag_command, shell=True, stderr=subprocess.STDOUT)
        tags = tags_output.decode('utf-8')
        # Extract artist and title from the tags
        artist = ""
        title = ""
        for line in tags.split('\n'):
            if line.startswith('artist'):
                artist = line.split('=')[1].strip()
            elif line.startswith('title'):
                title = line.split('=')[1].strip()
        return artist, title
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to extract ID3 tags: {e}")
        return None, None

def normalize_audio(track, artist, title):
    temp_file = "/tmp/normalized_temp.wav"
    log_message = f"{artist} - {title}"
    logging.debug(f"Log message: {log_message}")

    # Construct the sox command with the norm effect to normalize audio
    normalize_command = f"sox -t mp3 {track} -b 16 -r 44100 -c 2 {temp_file} norm"
    try:
        # Execute the normalization command
        subprocess.run(normalize_command, shell=True, check=True)
        # Apply ID3 tags to the normalized WAV file
        apply_tags_command = f'sox {temp_file} -t wav - {temp_file} artist="{artist}" title="{title}"'
        subprocess.run(apply_tags_command, shell=True, check=True)
        return temp_file, log_message
    except subprocess.CalledProcessError as e:
        logging.error(f"Normalization failed: {e}")
        return None, None

def load_config():
    config = configparser.ConfigParser()
    config.read('config.ini')
    return config['DEFAULT']

def generate_playlist():
    music_folder = "./music/"
    music_files = [file for file in os.listdir(music_folder) if file.endswith((".mp3", ".wav", ".flac", ".aac"))]
    stingers_folder = config.get('stingers_folder', './stingers/')
    stinger_files = [file for file in os.listdir(stingers_folder) if file.endswith((".mp3", ".wav", ".flac", ".aac"))]

    # Shuffle the music files
    random.shuffle(music_files)

    # Shuffle the stinger files
    random.shuffle(stinger_files)

    # Create playlist
    playlist = []

    # Add music files to playlist
    for file in music_files:
        playlist.append((os.path.join(music_folder, file), 'music'))

    # Add stinger files to playlist
    stinger_interval = config.getint('stinger_interval', 3)
    stinger_max_interval = config.getint('stinger_max_interval', 8)
    stinger_count = 0
    for file in stinger_files:
        playlist.append((os.path.join(stingers_folder, file), 'stinger'))
        stinger_count += 1
        if stinger_count >= stinger_interval:
            # Reset stinger count after random interval
            stinger_count = 0
            # Randomize next stinger interval
            stinger_interval = random.randint(3, stinger_max_interval)

    return playlist

def main():
    # Load configuration
    config = load_config()

    # Configure logging
    log_file = config.get('error_log_file', 'error.log')
    logging.basicConfig(filename=log_file, level=logging.DEBUG,
                        format='%(asctime)s - %(levelname)s - %(message)s')

    while True:
        try:
            # Generate playlist
            playlist = generate_playlist()

            # Iterate over playlist
            for track, track_type in playlist:
                if track_type == 'music':
                    # Extract ID3 tags
                    artist, title = extract_id3_tags(track)
                    if artist is None or title is None:
                        logging.error(f"Failed to extract ID3 tags for {track}.")
                        continue

                    # Normalize audio
                    normalized_file, log_message = normalize_audio(track, artist, title)
                    if normalized_file is None:
                        logging.error(f"Normalization failed for {track}.")
                        continue

                    logging.info(f"Normalized {log_message}")

                    # Stream the normalized file using ffmpeg
                    ffmpeg_command = f"ffmpeg -i {normalized_file} -f mp3 icecast://{config['icecast_url']}:{config['icecast_port']}/{config['mount_point']} -loglevel error"
                    subprocess.run(ffmpeg_command, shell=True, check=True)
                elif track_type == 'stinger':
                    # Stream the stinger file using ffmpeg
                    ffmpeg_command = f"ffmpeg -i {track} -f mp3 icecast://{config['icecast_url']}:{config['icecast_port']}/{config['mount_point']} -loglevel error"
                    subprocess.run(ffmpeg_command, shell=True, check=True)

        except Exception as e:
            logging.exception("An error occurred.")

        # Sleep for a day before regenerating playlist
        time.sleep(86400)

if __name__ == "__main__":
    main()
